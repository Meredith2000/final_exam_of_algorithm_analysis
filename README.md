# 算法分析期末试卷解析

## 第一题

> 题目：用伪代码描述一个二分查找算法的完整过程
>
> 题目类型：二分法

### 分析

下面是一个有序的列表，而红色背景的元素就是我们需要寻找的元素了

![截屏2020-12-19 下午1.33.19](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%881.33.19.png)

**注意：二分法查找要求列表中的值是有序的！！！**

**现在我们将列表中放入三个指针**，他们分别是：

- 指向列表头部的head指针 -> 0
- 指向列表尾部的tail指针 -> len(array)
- 指向列表中间的mid指针 -> int(head + mid)

![截屏2020-12-19 下午1.41.14](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%881.41.14.png)

**我们约定检索的规则如下：**

- 如果mid所指的值等于我们所要寻找的值，那么就认为找到了
- 如果mid所指的值大于我们要寻找的值，那么我们寻找的值，一定在mid的左边，则移动tail指针到mid的左边，并重新计算mid
- 如果mid所指的值小于我们要寻找的值，那么我们寻找的值，一定在mid的右边，则移动head指针到mid的右边，并重新计算mid
- 如果head > tail 那就说明列表中没有这个元素

### 查找过程

**下面我们进行第一次的比较：**

​	此时mid所代表的的是6号元素，其所对应的值是7，由于7小于我们所要寻找的11，所以head指向7号元素，mid = (head + tail)/2，所以mid所指的是9号元素，其值为10，对应图如下

![截屏2020-12-19 下午1.54.26](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%881.54.26.png)

**下面我们进行第三次的比较：**

​	此时mid所代表的的是9号元素，其所对应的值是10，由于10小于我们所要寻找的11，所以head指向10号元素，mid = (head + tail)/2，所以mid所指的是11号元素，其值为12，对应图如下

![截屏2020-12-19 下午1.58.07](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%881.58.07.png)

**下面我们进行第四次的比较：**

​	此时mid所代表的的是11号元素，其所对应的值是12，由于12大于我们所要寻找的11，所以tail指向10号元素，mid = (head + tail)/2，所以mid所指的是10号元素，其值为11，对应图如下

![截屏2020-12-19 下午2.01.37](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%882.01.37.png)

**下面我们进行第五次比较：**

​	此时mid所代表的的是10号元素，其所对应的值是11，11正是我们要寻找的元素！

### etc

此种算法的算法复杂度为**O(log(2n))**

## 第二题

> 题目：在2k*2k的棋盘覆盖问题中，如果k值等于3，残缺方块的行列序号分别是7和6，请给出此种状态下的覆盖过程描述并简单解释使用了何种算法以及本题使用这种算法的优势。
>
> 题目类型：分治法+递归
>
> [具体题目链接]: https://blog.csdn.net/weixin_43931548/article/details/105755520

### 分析

如下图所示，红色部分表示缺失的棋盘位置：

![截屏2020-12-19 下午2.23.47](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%882.23.47.png)

面对这样的题，我们可以把整个棋盘分成4个子棋盘，分别是**左上，右上，左下，右下**，如下图：

![截屏2020-12-19 下午2.41.44](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%882.41.44.png)

可以看出确实的格子是属于左上的，所以我们要在其余没有缺少的子棋盘中的指定一个做为缺少的（指定位置），如下图：

![截屏2020-12-19 下午2.49.19](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%882.49.19.png)

根据上面的过程可以不断的递归下去，每一个棋盘都可以分为四个子棋盘，直到最后只有一个格子的时候退出

### 伪代码演示

```python
def play_chess(棋盘的大小, 棋盘的顶点横坐标, 棋盘的顶点纵坐标, 缺少位置的横坐标, 缺少位置的纵坐标):
  # 递归的出口
  if size == 1:
    return
  # 首先进行棋盘的分割
  # 左上角
  if 缺失的格子在左上角:
    play_chess(棋盘位置调整到左上角，缩小规模)
  else:
    chess_board[中心点的左上方坐标] = trace_step
    play_chess(棋盘位置调整到左上角, 缩小规模, 更新缺少的点)

  # 右上角
  if 缺失的格子在右上角:
    play_chess(棋盘位置调整到右上角，缩小规模)
  else:
    chess_board[中心点的右上方坐标] = trace_step
    play_chess(棋盘位置调整到右上角, 缩小规模, 更新缺少的点)

  # 左下角
  if 缺失的格子在左下角:
    play_chess(棋盘位置调整到左下角，缩小规模)
  else:
    chess_board[中心点的左下方坐标] = trace_step
    play_chess(棋盘位置调整到左下角, 缩小规模, 更新缺少的点)
  
  # 右下角
  if 缺失的格子在右下角:
    play_chess(棋盘位置调整到右下角，缩小规模)
  else:
    chess_board[中心点的右下方坐标] = trace_step
    play_chess(棋盘位置调整到右下角, 缩小规模, 更新缺少的点)
```

## 第三题

> 题目：给定n种物品和一个背包。物品i的重量为wi，其价值为vi,背包的容量为C。使用动态规划方法分析并描述应该如何选择装入背包的物品，使得装入背包中物品的总价值最大？在选择装入背包时，对每种物品只有两种选择：即装入背包或不装入背包，不能将物品装入背包多次，也不能只装入部分某物品。
>
> 题目类型：0，1背包问题（动态规划）
>
> [具体题目链接]:https://www.jianshu.com/p/a66d5ce49df5

### 分析

这是一道典型的动态规划的题目，主要是要写出整个的状态转义方程，其实对于整体而言，一直在重复拿和不拿之间的关系，即找到拿或者不拿中间的最大值

这里我把表中的取值的过程简单写成一个函数：

```python
value_table[i][j] = max(拿的价值，不拿的价值)
```

**状态转移方程：**
$$
value\_table[i][j] = 
\begin{cases}
value\_table[i-1][j] \\\\
value[i] + value\_table[i-1][j-weight[i]]
\end{cases}
$$
建立表格之后，找到最大的就行了



## 第四题

> 题目：在最长公共子序列问题中，用c\[i][j]记录Xi和Yi的最长公共子序列的长度。其中，Xi={x1,x2…xi}，Yi={y1,y2…yi}。当i或j的值为0时，X和Y的最长公共子序列为空序列。请求出在一般情况下，由本问题的最优子结构性质所建立的递归关系式，给出推导过程。
>
> 题目类型：LCS 动态规划
>
> [具体题目链接]:https://blog.csdn.net/hrn1216/article/details/51534607

### 分析

这是一道动态规划的题目，状态转移方程如下

![截屏2020-12-25 上午10.29.44](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-25%20%E4%B8%8A%E5%8D%8810.29.44.png)

跟上面一样，建立表格后找到最大的就可以

## 第五题

> 题目：设计一个贪心算法（详细的流程图，或者 完整的伪代码，或者 有注释的源代码）， 把一个真分数表示为埃及分数之和的形式。所谓埃及分数，是指分子为1的分数。如：7/8=1/2+1/3+1/24。
>
> 题目类型：贪心算法
>
> [具体题目链接]:https://www.jianshu.com/p/da04c77e11d0

### 分析

贪心算法的思想是：找到局部最优解，那么整体就会最优

在这道题中，要把一个真分数转换为尽量少的埃及真分数，那么每次的在取分数的时候都找它最大的埃及真分数就行了

在这道题中，我运用的暴力+贪心的算法，由于分母越小的分数，值越大，所以**分母从2开始，不断地加1，直到比原来的数要小，然后这个数就是当前最大的埃及真分数了**

但是在做题的过程中，我看见网上有一种效率更加的高的方法，直接可以给出当前最大的埃及真分数，但是要用到数学方面的推倒，我这里就不做深究了，源码我放在了文件中，各位可以下下来运行。

## 第六题

> 题目：给定无向图G和m种不同的颜色，用这些颜色对图G的各顶点进行着色，每个顶点着一种颜色。分析是否有一种着色法使G中每条边的两个顶点着不同颜色？使用回溯法分析本问题，并画出在此框架下的解空间树（并添加适当注释）。
>
> 题目类型：回溯法
>
> [具体题目链接]:https://wenku.baidu.com/view/7d7ed91e6bd97f192279e978.html

### 分析

回溯法实际上就是深度优先搜索+减枝

我们将问题简化一下，设置一下边界，就成了下面这个无向图

![截屏2020-12-29 下午7.45.10](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%887.45.10.png)

对于无向图的在电脑中的保存我使用了邻接矩阵的方式来存放

从1节点开始，有三种不同的颜色选择，形成了三个子节点，而这三个子节点又可以分别形成各自的三个不同的子节点，这样就形成了一个数，通过判断有没有颜色一样的来进行减枝，如下图

![截屏2020-12-29 下午7.45.03](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%887.45.03.png)

## 第七题

> 题目：有一批共n个集装箱要装上两艘载重量分别为c1和c2的轮船，其中集装箱i的重量为wi，且集装箱总重量小于两艘船的载重总量。请确定是否有一个合理的装载方案可将所有的集装箱装上这两艘轮船。这是经典的装载问题，在此问题中，当我们将问题变换成本质上是研究如何将第一艘船尽可能装满后，在使用分支限界的方法时，是如何进行“分支限界”的？
>
> 题目类型：分支限界
>
> [算法参考链接]:https://blog.csdn.net/weixin_41250910/article/details/94672557
> [算法参考链接]:https://blog.csdn.net/songzitea/article/details/52263209

实际上分支限界就是广度优先搜索，类似于上一题回溯法，只有“取”和“不取”的两种状态

这里我通过简单的FIFO来广度优先遍历树，实际上FIFO算法就是一个队列，将队列中的头看作是根节点，从而衍生出多个子节点，在这道题中，每个节点都会有两个子节点，分别是“取”或者是“不取”，在确定子节点之后，将生成的两个子节点放入队列的末尾，知道队列中的长度为空，这个树就遍历结束了

通过设置分支限界可以有效减小问题的规模，这里有两个限界的点，第一个超过了船最大容量，我们称之为“上界”，这种只会发生在“取”的情况下，第二个是下面的所有物品中之和加上头结点不能大于现有最大的节点，这就说明下面就算是全取，也不可能大于现有的最优解，所以这个节点可以不入队。

## 第八题

> 题目：结合你在数据结构与算法课程中获取的知识，自行设计一种面向字符串的单个关键字查找算法，假定查找范围为普通的一维数组。要求：与之前我们所学的所有查找算法都不完全相同。使用详细的流程图，完整的伪代码，有注释的源代码，等其中的任意一种描述方法均可

这道题，我的想法借鉴于哈夫曼编码的压缩算法，主要思想如下：

首先根据母串建立如下字典索引：

![截屏2021-01-02 下午4.51.41](https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-02%20%E4%B8%8B%E5%8D%884.51.41.png)

在母串中的所有字母都会在字典中有一个key，而每个key所对应的value实际上是一个数组，这个数组中的值，就是在母串中出现的位置

在查找的时候，先找到子串中的第一个字符，并在字典中找到其对应的value数组，取到value数组之后，将之中的所有索引都分别+1，再与子串下一个字符对应的value数组进行比较，并只保留相同的部分，一直不断重读，知道子串遍历结束，或者两个之间没有重复的元素

最后得到的结果就表示着子串在母串中结尾字符的位置
