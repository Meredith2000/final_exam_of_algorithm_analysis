# 算法分析期末试卷解析

## 第一题

> 题目：用伪代码描述一个二分查找算法的完整过程
>
> 题目类型：二分法

### 分析

下面是一个有序的列表，而红色背景的元素就是我们需要寻找的元素了

![截屏2020-12-19 下午1.33.19](/Users/apple/Desktop/截屏2020-12-19 下午1.33.19.png)

**注意：二分法查找要求列表中的值是有序的！！！**

**现在我们将列表中放入三个指针**，他们分别是：

- 指向列表头部的head指针 -> 0
- 指向列表尾部的tail指针 -> len(array)
- 指向列表中间的mid指针 -> int(head + mid)

![截屏2020-12-19 下午1.41.14](/Users/apple/Desktop/截屏2020-12-19 下午1.41.14.png)

**我们约定检索的规则如下：**

- 如果mid所指的值等于我们所要寻找的值，那么就认为找到了
- 如果mid所指的值大于我们要寻找的值，那么我们寻找的值，一定在mid的左边，则移动tail指针到mid的左边，并重新计算mid
- 如果mid所指的值小于我们要寻找的值，那么我们寻找的值，一定在mid的右边，则移动head指针到mid的右边，并重新计算mid
- 如果head > tail 那就说明列表中没有这个元素

### 查找过程

**下面我们进行第一次的比较：**

​	此时mid所代表的的是6号元素，其所对应的值是7，由于7小于我们所要寻找的11，所以head指向7号元素，mid = (head + tail)/2，所以mid所指的是9号元素，其值为10，对应图如下

![截屏2020-12-19 下午1.54.26](/Users/apple/Desktop/截屏2020-12-19 下午1.54.26.png)

**下面我们进行第三次的比较：**

​	此时mid所代表的的是9号元素，其所对应的值是10，由于10小于我们所要寻找的11，所以head指向10号元素，mid = (head + tail)/2，所以mid所指的是11号元素，其值为12，对应图如下

![截屏2020-12-19 下午1.58.07](/Users/apple/Desktop/截屏2020-12-19 下午1.58.07.png)

**下面我们进行第四次的比较：**

​	此时mid所代表的的是11号元素，其所对应的值是12，由于12大于我们所要寻找的11，所以tail指向10号元素，mid = (head + tail)/2，所以mid所指的是10号元素，其值为11，对应图如下

![截屏2020-12-19 下午2.01.37](/Users/apple/Desktop/截屏2020-12-19 下午2.01.37.png)

**下面我们进行第五次比较：**

​	此时mid所代表的的是10号元素，其所对应的值是11，11正是我们要寻找的元素！

### etc

此种算法的算法复杂度为**O(log(2n))**

## 第二题

> 题目：在2k*2k的棋盘覆盖问题中，如果k值等于3，残缺方块的行列序号分别是7和6，请给出此种状态下的覆盖过程描述并简单解释使用了何种算法以及本题使用这种算法的优势。
>
> 题目类型：分治法+递归
>
> [具体题目链接]: https://blog.csdn.net/weixin_43931548/article/details/105755520

### 分析

如下图所示，红色部分表示缺失的棋盘位置：

![截屏2020-12-19 下午2.23.47](/Users/apple/Desktop/截屏2020-12-19 下午2.23.47.png)

面对这样的题，我们可以把整个棋盘分成4个子棋盘，分别是**左上，右上，左下，右下**，如下图：

![截屏2020-12-19 下午2.41.44](/Users/apple/Desktop/截屏2020-12-19 下午2.41.44.png)

可以看出确实的格子是属于左上的，所以我们要在其余没有缺少的子棋盘中的指定一个做为缺少的（指定位置），如下图：

![截屏2020-12-19 下午2.49.19](/Users/apple/Desktop/截屏2020-12-19 下午2.49.19.png)

根据上面的过程可以不断的递归下去，每一个棋盘都可以分为四个子棋盘，直到最后只有一个格子的时候退出

### 伪代码演示

```python
def play_chess(棋盘的大小, 棋盘的顶点横坐标, 棋盘的顶点纵坐标, 缺少位置的横坐标, 缺少位置的纵坐标):
  # 递归的出口
  if size == 1:
    return
  # 首先进行棋盘的分割
  # 左上角
  if 缺失的格子在左上角:
    play_chess(棋盘位置调整到左上角，缩小规模)
  else:
    chess_board[中心点的左上方坐标] = trace_step
    play_chess(棋盘位置调整到左上角, 缩小规模, 更新缺少的点)

  # 右上角
  if 缺失的格子在右上角:
    play_chess(棋盘位置调整到右上角，缩小规模)
  else:
    chess_board[中心点的右上方坐标] = trace_step
    play_chess(棋盘位置调整到右上角, 缩小规模, 更新缺少的点)

  # 左下角
  if 缺失的格子在左下角:
    play_chess(棋盘位置调整到左下角，缩小规模)
  else:
    chess_board[中心点的左下方坐标] = trace_step
    play_chess(棋盘位置调整到左下角, 缩小规模, 更新缺少的点)
  
  # 右下角
  if 缺失的格子在右下角:
    play_chess(棋盘位置调整到右下角，缩小规模)
  else:
    chess_board[中心点的右下方坐标] = trace_step
    play_chess(棋盘位置调整到右下角, 缩小规模, 更新缺少的点)
```

## 第三题

> 题目：给定n种物品和一个背包。物品i的重量为wi，其价值为vi,背包的容量为C。使用动态规划方法分析并描述应该如何选择装入背包的物品，使得装入背包中物品的总价值最大？在选择装入背包时，对每种物品只有两种选择：即装入背包或不装入背包，不能将物品装入背包多次，也不能只装入部分某物品。
>
> 题目类型：0，1背包问题（动态规划）
>
> [具体题目链接]:https://www.jianshu.com/p/a66d5ce49df5

### 分析

这是一道典型的动态规划的题目，主要是要写出整个的状态转义方程，这里我把表中的取值的过程简单写成一个函数：

```python
value_table[i][j] = max(拿的价值，不拿的价值)
```

**状态转移方程：**
$$
value\_table[i][j] = 
\begin{cases}
value\_table[i-1][j] \\
value[i] + value\_table[i-1][j-weight[i]]
\end{cases}
$$
